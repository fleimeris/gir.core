using System.Linq;
using Generator.Model;

namespace Generator.Renderer.Public;

internal static class ClassConstructOnlyProperties
{
    public static string Render(GirModel.Class cls)
    {
        return $@"
using System;
using System.Linq;
using GObject;
using System.Runtime.InteropServices;
#nullable enable

namespace {Namespace.GetPublicName(cls.Namespace)}
{{
    // AUTOGENERATED FILE - DO NOT MODIFY

    public partial class {cls.Name}
    {{
        {RenderConstructor(cls)}
    }}
}}";
    }

    private static string RenderConstructor(GirModel.Class cls)
    {
        try
        {
            var properties = cls.Properties
                .Where(property => property.ConstructOnly)
                .Where(Property.IsEnabled)
                .ToList();

            var parameters = properties
                .Select(property => $"{GetTypeName(property)} {property.Name.ToCamelCase()} = null")
                .Join(", ");

            var baseParameters = properties
                .Select(property => $"ConstructArgument.With(\"{property.Name}\", {property.Name.ToCamelCase()})")
                .Join(", ");

            return $"public {cls.Name}({parameters}) : base({baseParameters}){{}}";
        }
        catch (System.Exception ex)
        {
            var message = $"Could not generate constructor for construct only properties: {ex.Message}";
            Log.Warning($"Class {Namespace.GetPublicName(cls.Namespace)}.{cls.Name}: {message})");
            return $"//TODO: {message}";
        }
    }
    
    private static string GetTypeName(GirModel.Property property)
    {
        return property.AnyType.Match(
            type => type switch
            {
                GirModel.ComplexType c => ComplexType.GetFullyQualified(c) + "?",
                _ => Type.GetName(type) + "?"
            },
            arrayType => ArrayType.GetName(arrayType) + "?"
        );
    }
}
